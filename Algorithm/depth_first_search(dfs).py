# -*- coding: utf-8 -*-
"""Depth_First_Search(DFS).ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1MjhQCOwdjaEGuaAt6AHmy9ZrqJkQQ08V

Pre_Order
"""

# Using a Python dictionary to act as an adjacency list
graph = {
  'A' : ['B','C'],
  'B' : ['D', 'E'],
  'D' : ['H','I'],
  'H' : [],
  'I' : [],
  'E' : ['J','K'],
  'J' : [],
  'K' : [],
  'C' : ['F','G'],
  'F' : ['L','M'],
  'L' : [],
  'M' : [],
  'G' : ['N','O'],
  'N' : [],
  'O' : []
}

visited = set() # Set to keep track of visited nodes of graph.

def dfs(visited, graph, node):  #function for dfs 
    if node not in visited:
        print (node,end=" ")
        visited.add(node)
        for neighbour in graph[node]:
            dfs(visited, graph, neighbour)

# Driver Code
print("Following is the Depth-First Search")
dfs(visited, graph, 'A')

"""Post_Order"""

# Data structure to store a binary tree node
class Node:
  def __init__(self, data=None, left=None, right=None):
    self.data = data
    self.left = left
    self.right = right
 
 
# Recursive function to perform postorder traversal on the tree
def postorder(root):
  # return if the current node is empty
  if root is None:
    return
 
  # Traverse the left subtree
  postorder(root.left)
 
  # Traverse the right subtree
  postorder(root.right)
 
  # Display the data part of the root (or current node)
  print(root.data, end=' ')
 
 
if __name__ == '__main__':
  root = Node('A')
  root.left = Node('B')
  root.right = Node('C')
  root.left.left = Node('D')
  root.left.right = Node('E')
  root.left.left.left = Node('H')
  root.left.left.right = Node('I')
  root.left.right.left = Node('J')
  root.left.right.right = Node('K')
  root.right.left = Node('F')
  root.right.right = Node('G')
  root.right.left.left = Node('L')
  root.right.left.right = Node('M')
  root.right.right.left = Node('N')
  root.right.right.right = Node('O')
 
  postorder(root)

"""In_Order"""

# Data structure to store a binary tree node
class Node:
  def __init__(self, data=None, left=None, right=None):
    self.data = data
    self.left = left
    self.right = right
 
 
# Recursive function to perform inorder traversal on the tree
def inorder(root):
  if root is None:
    return
 
  # Traverse the left subtree
  inorder(root.left)
 
  # Display the data part of the root (or current node)
  print(root.data, end=' ')
 
  # Traverse the right subtree
  inorder(root.right)
 
 
if __name__ == '__main__':
  root = Node('A')
  root.left = Node('B')
  root.right = Node('C')
  root.left.left = Node('D')
  root.left.right = Node('E')
  root.left.left.left = Node('H')
  root.left.left.right = Node('I')
  root.left.right.left = Node('J')
  root.left.right.right = Node('K')
  root.right.left = Node('F')
  root.right.right = Node('G')
  root.right.left.left = Node('L')
  root.right.left.right = Node('M')
  root.right.right.left = Node('N')
  root.right.right.right = Node('O')
   
  inorder(root)