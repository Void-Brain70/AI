# -*- coding: utf-8 -*-
"""A*_Search_Map_18101070.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/162aNslojM5OGiowfGKUp4fjM_xxIWdnQ
"""

# import pandas libaries
import pandas as pd
pd.set_option('mode.chained_assignment', None) #Sets the value of the specified option.
df = pd.read_csv('/content/MapData.csv') # for read csv file
df # show dataframe

# Calculated heuristic value accrodding to my id
id = 70
A = id%4+2  # Home(Narayanganj)
B = id%5+3  # Chasara
C = id%6+1  # Signbord
D = id%5+2  # Ponchoboti
E = id%4+1  # Jatrabari
F = id%4+3  # Gandaria
G = id%5+4  # Gulistan
I = id%6+2  # Shahbag
J = id%5+3  # Newmarket

# we know goal state heuristic value are 0 so h(K)UAP = 0 


A,B,C,D,E,F,G,I,J

# get input from user start node and goal node 
# in this case start node 'A(Home{Narayanganj})' and goal node 'K(UAP)'
start = input('Give Start Node->').upper()
goal = input('Give Goal Node->').upper()

# In this part show the start and goal node
print("The node are->")
start,goal

# In this part change dataframe  columns name [0,1,2,3] to ['Parent','Child','g(n)','h(n)']
df.columns = ['Parent', 'Child', 'g(n)', 'h(n)']
# Cast a pandas object to a specified dtype
# Now we will g(n) and h(n) convert it into 'int32' type. for path calculation
# This Struct is used to represents 32-bit signed integer. The Int32 can store both types of values including negative and positive between the ranges of -2147483648 to +2147483647.
df['g(n)'] = df['g(n)'].astype('int32')  # Cast all columns to int32 4 bytes
df['h(n)'] = df['h(n)'].astype('int32') 
df

ls = []
for i in  df.values: #Return a Numpy representation of the DataFrame.
    # index 0 1 2 3 
    if i[3] =='A': 
        i[3]=A
    elif i[1]=='B':
        i[3]=B
    elif i[1]=='C':
        i[3]=C 
    elif i[1]=='D':
        i[3]=D
    elif i[1]=='E':
        i[3]=E
    elif i[1]=='F':
        i[3]=F
    elif i[1]=='G':
        i[3]=G
    elif i[1]=='I':
        i[3]=I
    elif i[1]=='J':
        i[3]=J
    ls.append(i) # append all the h(n) value accoding to parent h(n)

path = [start] # list 
# store dataframe with ('ls' value) in new_df for next part 
new_df = pd.DataFrame(ls,columns=['Parent', 'Child', 'g(n)', 'h(n)'])
new_df

path_cost = 0 # initially path cost 0
# add a dictionary for realistic 
dic = {
        'A' : 'Home(Narayanganj)',
        'B' : 'Chasara',
        'C' : 'Signboard',
        'D' : 'Ponchobti	',
        'E' : 'Jatrabari',
        'F' : 'Gandaria',
        'G' : 'Gulistan',
        'I' : 'Shahbag',
        'J' : 'Newmarket',
        'K' : 'UAP',
}
while True:
    if start==goal: # if goal node == start node it's means the goal node and start are same so the code break.
      break
    
    # if not same goal node == start node . then the execution start
    ddf = new_df[sdf.Parent==start] # first check our input(start) and dataframe firts Parent node()  are same the put the value of 'New_df' in 'df'
    ddf['f(n)']=ddf[['g(n)','h(n)']].sum(axis=1) # then calculated f(n)=g(n)+h(n) and create new axis f(n)
    
    # sort_values(_) Sort by the values along either axis.
    # reset_index(_) Reset the index of the DataFrame, and use the default one instead. If the DataFrame has a MultiIndex, this method can remove one or more levels.
    ddf=ddf.sort_values(by='f(n)',ascending=True).reset_index(drop=True)
    
    # Print the table of calcultion content
    print(ddf) 
    
    #.loc[] is primarily label based, but may also be used with a boolean array.
    start = ddf.loc[0].Child # Use an .loc array for add all possible start to child cost path and store .loc array for new start node 
    path_cost+=ddf.loc[0]['g(n)'] # sum all the possible cost path g(n)
    path.append(start) # finally add all the possible cost path g(n) and store in path variable

# Print the shortest path using a loop 
print('Shortes path are->') 
for i in range(len(path)-1):
        print(dic[path[i]], end=' -> ')       
print(dic[path[len(path) - 1]])

# Print the path cost
print('Total path cost->',path_cost+list(ddf[ddf['Child']==goal]['h(n)'])[0])