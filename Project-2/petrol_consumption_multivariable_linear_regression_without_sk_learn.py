# -*- coding: utf-8 -*-
"""Petrol_Consumption_Multivariable_Linear_Regression_Without_SK_learn.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1RhnZKwNBmUhKIvC7ppJHO5UmQk-4OOnw

**Petrol_Consumption_Multivariable_Linear_Regression_Without_SK-Learn**
"""

# Commented out IPython magic to ensure Python compatibility.
# dataset
# Importing all required packages
import os
import io
import pandas as pd # for dataframe
import matplotlib.pyplot as plt # for ploting data
import seaborn as sns # # Seaborn is a library that uses Matplotlib underneath to plot graphs.
# %matplotlib inline

# For dataset 
df = pd.read_csv('/content/petrol_consumption.csv') # A simple way to store big data sets is to use CSV files
df.head() # Return the first 5 rows of the DataFrame.

# rename() Rename the row,column indexes of the DataFrame
df = df.rename(columns={'Petrol_tax': 'x1', 'Average_income': 'x2', 'Paved_Highways': 'x3', 'Population_Driver_licence(%)': 'x4', 'Petrol_Consumption': 'y'})
df.head() # Return the first 5 rows of the DataFrame.

# initialize x1-x4 and y for dataframe column indexes
x1 = df.x1
x2 = df.x2 
x3 = df.x3 
x4 = df.x4
y  = df.y

# Define Predict function 
# initialize t0-t4 for value of theta or Coefficient
# equation  y =  t0 + t1 * x1 + t2 * x2 + t3 * x3 + t4 * x4
def predict(t0,t1,t2,t3,t4,x1,x2,x3,x4):
    return t0 + t1 * x1 + t2 * x2 + t3 * x3 + t4 * x4

# Define computeCost function 
def computeCost(t0,t1,t2,t3,t4,x1,x2,x3,x4,y):
    # Getting number of data
    m = float(len(y))
    loss = [] # initialize list for stroe 
    # Iterating over all of the data
    for i in range(len(y)):
        # Getting prediction using the parameter [t0, t1, t2 ,t3,4]
        h = predict(t0,t1,t2,t3,t4,x1[i],x2[i],x3[i],x4[i])
        # Adding the losses to the list
        loss.append((h - y[i])**2)
    # Printing Hypothesis Function Value after each epoch   
    print("Hypothesis Function Value is: ",loss)
    # Printing Updated parameters after each epoch
    print("Updated parameters are: ",t0,t1,t2,t3,t4)
    return (sum(loss) / (2 * m))

# define plot function 
def plot_cost_vs_iteration(costs):
    plt.plot([i for i in range(len(costs))],costs)
    plt.title("Cost vs Iteration")
    plt.xlabel("Iteration")
    plt.ylabel("Cost")
    plt.show()

# Parameters to be updated
t0 = 425.599332
t1 = -40.016660
t2 = -0.065413
t3 = -0.004741
t4 = 1341.862121

# Data Length
m = float(len(y))

# Epoch [No. of iterations]
epoch = 30

# Learning Rate
alpha =  0.001

# Costs
costs = []

# Batch Gradient Descent
for k in range(epoch):

    _theta_temp_0 = t0 + (alpha / m) * sum([(y[k] - predict(t0,t1,t2,t3,t4,x1[k],x2[k],x3[k],x4[k]))
                                                     for k in range(len(y))
                                                 ])

    _theta_temp_1 = t1 + (alpha / m) * sum([(y[k] - predict(t0,t1,t2,t3,t4,x1[k],x2[k],x3[k],x4[k])) * x1[k]
                                                     for k in range(len(y))
                                                 ])

    _theta_temp_2 = t2 + (alpha / m) * sum([(y[k] - predict(t0,t1,t2,t3,t4,x1[k],x2[k],x3[k],x4[k])) * x2[k]
                                                     for k in range(len(y))
                                                 ])

    _theta_temp_3 = t3 + (alpha / m) * sum([(y[k] - predict(t0,t1,t2,t3,t4,x1[k],x2[k],x3[k],x4[k])) * x3[k]
                                                     for k in range(len(y))
                                                 ])     

    _theta_temp_4 = t4 + (alpha / m) * sum([(y[k] - predict(t0,t1,t2,t3,t4,x1[k],x2[k],x3[k],x4[k])) * x4[k]
                                                     for k in range(len(y))
                                                 ])       



    t0 = _theta_temp_0
    t1 = _theta_temp_1
    t2 = _theta_temp_2
    t3 = _theta_temp_3
    t4 = _theta_temp_4

    # Calculating cost
    cost = computeCost(t0,t1,t2,t3,t4,x1,x2,x3,x4, y)

    # Saving it to the list for future use
    costs.append(cost)

    # Printing cost after each epoch
    print("Cost: {}".format(cost))

# Plotting Cost vs Iteration Graph
plot_cost_vs_iteration(costs)

# prediction result 
predict(425.599332,-40.016660,-0.065413,-0.004741,1341.862121,9.0,3571,1976,0.525)

# Manually calculation result
# Petrol_Consumption = t0 + t1*Petrol_tax + t2*Average_income + t3*Paved_Highways + t4*Population_Driver_licence(%) + intercept
Petrol_Consumption = 425.599332+(-40.016660)*9.0	+(-0.065413)*3571+(-0.004741)*1976+1341.862121*0.525
Petrol_Consumption